* iTerm 终端
** 主题
   github上有一个iTerm的主题repo,
   地址: https://github.com/mbadolato/iTerm2-Color-Schemes
   使用: 将该代码下载到本地文件系统中, 之后运行iterm, 将主题文件导入即可使用
* 技巧
** tree命令的一个等价实现
   find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g'
   该等价方式的好处是可以显示中文名的文件，但是tree显示中文为乱码
** 给命令绑定一个宏或按键  
   在进行按键绑定的时候，需要首先获取按键对应的字符序列，比如获取F12的字符序列的方法：
   先按下Ctrl+V然后按下F12，就可以得到F12的字符序列，^[[24~
   接着使用bind进行绑定：
   bind '"\e[24~":"date"' #bash 中可以使用该方法
   showkey -a命令也可以显示按键对应的字符序列
** 查看当前系统支持的所有命令列表
   compgen -c # bash可以，zsh不能运行
** 打印目录栈
   目录栈是使用pushd popd来操作，打印可以使用dirs
** 移除正在运行的进程
   linux中可以使用：disown -r
** bash 中的hash命令
   linux命令'hash'管理着一个内置的哈希表, 记录了已执行过的命令的完整路径,
   用该命令可以打印出你所使用过的命令以及执行的次数
* Better Bash scripting in 15 minutes
  http://blog.jobbole.com/65808/
** start every bash script with the following prolog
   #!/bin/bash
   set -o nounset # shorthands set -u
   set -o errexit # shorthands set -e
   this will take care of two very common errors:
   1. referencing undefined variable(which default to "")
   2. ignoring falling commands

   in the “errexit” mode, while a valuable first line of defense,
   does not catch all failures, i.e. under certain circumstances failing commands will go undetected
   see more: https://groups.google.com/forum/?fromgroups#!topic/gnu.bash.bug/-9ySnEo1WrQ
** functions
   Bash lets you define functions which behave like other commands
   <code -- functions>
** variable annotations
   Bash allows for a limited form of variable annotations
   local(for local variables inside a function)
   readonly(for read-only variable)

   Strive to annotate almost all variables in a bash script with either local or readonly
** favor $() over backticks(`)
   $()also permits nesting without the quoting headaches
** favor [[ \]\] over []   
   [[]] avoids problems like unexpected pathname expansion, offers some syntactical improvements,
   and adds new functionality:
   Operator        Meaning
   ||             logical or (double brackets only)
   &&           logical and (double brackets only)
   <            string comparison (no escaping necessary within double brackets)
   -lt          numerical comparison
   =             string matching with globbing
   ==         string matching with globbing (double brackets only, see below)
   =~            string matching with regular expressions (double brackets only , see below)
   -n            string is non-empty        
   -z            string is empty
   -eq           numerical equality
   -ne           numerical inequality
   <code --regular>
** string manipulation   
   bash has a number of ways to mainpulate strings
*** basic
    <code --string>
** avoiding temporary files    
   Some commands expect filenames as parameters  so straightforward pipelining does not work.
   This is where <() operator comes in handy as it takes a command and transforms it into something
   <code -- temporary files>
** Built-In Variables
   For reference
   $0   name of the script
   $n   positional parameters to script/function
   $$   PID of the script
   $!    PID of the last command executed (and run in the background)
   $?   exit status of the last command  (${PIPESTATUS} for pipelined commands)
   $#   number of parameters to script/function
   $@  all parameters to script/function (sees arguments as separate word)
   $*    all parameters to script/function (sees arguments as single word)
   Note
   $*   is rarely the right choice.
   $@  handles empty parameter list and white-space within parameters correctly
   $@ should usually be quoted like so "$@"
** debugging   
   To perform a syntax check/dry run of your bash script run:
   bash -n myscript.sh

   To produce a trace of every command executed run:
   bash -v myscripts.sh

   To produce a trace of the expanded command use:
   bash -x myscript.sh

   -v and -x can also be made permanent by adding
   set -o verbose and set -o xtrace to the script prolog.
   This might be useful if the script is run on a remote machine, e.g.
   a build-bot and you are logging the output for remote inspection.
** Signs you should not be using a bash script
   your script is longer than a few hundred lines of code
   you need data structures beyond simple arrays
   you have a hard time working around quoting issues
   you do a lot of string manipulation
   you do not have much need for invoking other programs or pipe-lining them
   you worry about performance
   Instead consider scripting languages like Python or Ruby.
** lea data
   http://tldp.org/LDP/abs/html/
* 后台任务
** 执行一个后台任务
   可以在需要执行的命令后加上&即可
** 通过ctrl+z和bg命令将当前任务切换到后台
   先使用ctrl+z将当前任务暂停
   执行bg命令将任务切换到后台执行
   使用jobs命令查看所有的后台任务   
** fg命令将后台任务切换到前台
   fg命令不带参数，则将最近的后台任务切换到前台
   如果有多个任务，可以先使用jobs命令列出所有任务号和对应命令
   fg %1将一号任务切换到前台
** 通过kill %结束指定的后台任务   
   假如你想杀死指定的后台任务，用kill %任务号就行了。下面是杀死2号任务的例子
   kill %2
